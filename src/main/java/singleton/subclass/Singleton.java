package singleton.subclass;

/**
 * Пример субклассирования Singleton. Одна из проблем субклассирования его
 * связана с приватностью конструктора. Класс с приватным конструктором
 * расширить нельзя. Следовательно, конструктор придется изменить, чтобы
 * он был защищенным или публичным. Но тогда класс перестанет быть синглетным,
 * потому что другие классы смогут создавать его экземпляры.
 *
 * Изменение конструктора создает другую проблему. Реализация паттерна
 * основана на статической переменной, поэтому при прямолинейном субклассировании
 * все производные классы будут совместно использовать одну переменную экземпляра.
 * Поэтому при субклассировании придется реализовать в базовом классе некое подо-
 * бие системы управления доступом. Как и многие паттерны, этот не расчитан на биб-
 * лиотечное использование, а его поддержка элементарно добавляется в любой сущест-
 * вующий класс. Если в приложении используется большое количество синглетных
 * классов - стоит пересмотреть архитектуру.
 */
public class Singleton {
    protected static Singleton uniqueInstance;

    // simpleremoteWL useful instance variables here

    protected Singleton() {}

    public static synchronized Singleton getInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }

    // simpleremoteWL useful methods here
}